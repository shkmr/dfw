/* Copyright (C) 2002 Chris Liechti and Steve Underwood
 
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:
 
     1. Redistributions of source code must retain the above copyright notice,
        this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. The name of the author may not be used to endorse or promote products
        derived from this software without specific prior written permission.
 
   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
   EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
   OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
   Implementation of a dummy `skeleton' target for the GDB proxy server.
   
   Exported Data:
     skeletone_target            - target descriptor of the `skeleton' target 
  
   Imported Data:
     None     
  
   Static Data:
     skeleton_XXXX               - static data representing status and 
                                   parameters of the target 
  
   Global Functions:  
     None
  
   Static Functions:  
     skeleton_XXXX              - methods comprising the `skeleton' target.
                                  A description is in file gdbproxy.h
 
     skeleton_                  - local finctions
     skeleton_command
 
   $Id: target_fet430uif.c,v 1.1.1.1 2006/04/10 01:57:25 skimu Exp $ */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <stdarg.h>

#include "gdbproxy.h"

#if HAVE_GETOPT_H
#include <getopt.h>
#elif WIN32
#include "getopt.h"
#elif defined(__FreeBSD__)
#include "getopt.h"
#endif

#include "usbcom.h"
#include "fet430.h"


/* Note: we are using prefix 'skeleton' for static stuff in
   order to simplify debugging of the target code itself */

/* TODO: Put the correct values for the real target in these macros */
#define RP_FET430UIF_MIN_ADDRESS             0x0U
#define RP_FET430UIF_MAX_ADDRESS             0xFFFFU
#define RP_FET430UIF_REG_DATATYPE            uint16_t
#define RP_FET430UIF_REG_BYTES               (16*sizeof(uint16_t))
#define RP_FET430UIF_NUM_REGS                16
#define RP_FET430UIF_REGNUM_PC               0  /* Program counter reg. number */
#define RP_FET430UIF_REGNUM_SP               1  /* Stack pointer reg. number */
#define RP_FET430UIF_REGNUM_FP               4  /* Frame pointer reg. number */

#define RP_FET430UIF_MAX_BREAKPOINTS         10

/* Some example states a real target might support. */
#define RP_FET430UIF_TARGET_STATE_RUNNING                    0
#define RP_FET430UIF_TARGET_STATE_STOPPED                    1
#define RP_FET430UIF_TARGET_STATE_SINGLE_STEP_COMPLETE       2
#define RP_FET430UIF_TARGET_STATE_BREAKPOINT_HIT             3

/*
 * Target methods, static
 */
static void  fet430uif_help(const char *prog_name);
static int   fet430uif_open(int argc,
                           char * const argv[],
                           const char *prog_name,
                           log_func log_fn);
static void  fet430uif_close(void);
static int   fet430uif_connect(char *status_string,
                              size_t status_string_size,
                              int *can_restart);
static int   fet430uif_disconnect(void);
static void  fet430uif_kill(void);
static int   fet430uif_restart(void);
static void  fet430uif_stop(void);
static int   fet430uif_set_gen_thread(rp_thread_ref *thread);
static int   fet430uif_set_ctrl_thread(rp_thread_ref *thread);
static int   fet430uif_is_thread_alive(rp_thread_ref *thread, int *alive);
static int   fet430uif_read_registers(uint8_t *data_buf,
                                     uint8_t *avail_buf,
                                     size_t buf_size,
                                     size_t *read_size);
static int   fet430uif_write_registers(uint8_t *data_buf, size_t write_size);
static int   fet430uif_read_single_register(unsigned int reg_no,
                                           uint8_t *data_buf,
                                           uint8_t *avail_buf,
                                           size_t buf_size,
                                           size_t *read_size);
static int   fet430uif_write_single_register(unsigned int reg_no,
                                            uint8_t *data_buf,
                                            size_t write_size);
static int   fet430uif_read_mem(uint64_t addr,
                               uint8_t *data_buf,
                               size_t req_size,
                               size_t *actual_size);
static int   fet430uif_write_mem(uint64_t addr,
                                uint8_t *data_buf,
                                size_t req_sise);
static int   fet430uif_resume_from_current(int step, int sig);
static int   fet430uif_resume_from_addr(int step,
                                       int sig,
                                       uint64_t addr);
static int   fet430uif_go_waiting(int sig);
static int   fet430uif_wait_partial(int first,
                                   char *status_string,
                                   size_t status_string_len,
                                   out_func out,
                                   int *implemented,
                                   int *more);
static int   fet430uif_wait(char *status_string,
                           size_t status_string_len,
                           out_func out,
                           int *implemented);
static int   fet430uif_process_query(unsigned int *mask,
                                    rp_thread_ref *arg,
                                    rp_thread_info *info);
static int   fet430uif_list_query(int first,
                                 rp_thread_ref *arg,
                                 rp_thread_ref *result,
                                 size_t max_num,
                                 size_t *num,
                                 int *done);
static int   fet430uif_current_thread_query(rp_thread_ref *thread);
static int   fet430uif_offsets_query(uint64_t *text,
                                    uint64_t *data,
                                    uint64_t *bss);
static int   fet430uif_crc_query(uint64_t addr,
                                size_t len,
                                uint32_t *val);
static int   fet430uif_raw_query(char *in_buf,
                                char *out_buf,
                                size_t out_buf_size);
static int   fet430uif_remcmd(char *in_buf, out_func of, data_func df);
static int   fet430uif_add_break(int type, uint64_t addr, unsigned int len);
static int   fet430uif_remove_break(int type, uint64_t addr, unsigned int len);

//Table of remote commands following
static int fet430uif_rcmd_help(int argc, char *argv[], out_func of, data_func df);  //proto for table entry

static uint32_t crc32(uint8_t *buf, size_t len, uint32_t crc);

#define RCMD(name, hlp) {#name, fet430uif_rcmd_##name, hlp}  //table entry generation

//Table entry definition
typedef struct
{
    const char *name;                                   // command name
    int (*function)(int, char**, out_func, data_func);  // function to call
    const char *help;                                   // one line of help text
} RCMD_TABLE;

/*
 * Global target descriptor 
 */
rp_target fet430uif_target =
{
    NULL,      /* next */
    "fet430uif",
    "Texas Instrument's FET430UIF USB interface",
    fet430uif_help,
    fet430uif_open,
    fet430uif_close,
    fet430uif_connect,
    fet430uif_disconnect,
    fet430uif_kill,
    fet430uif_restart,
    fet430uif_stop,
    fet430uif_set_gen_thread,
    fet430uif_set_ctrl_thread,
    fet430uif_is_thread_alive,
    fet430uif_read_registers,
    fet430uif_write_registers,
    fet430uif_read_single_register,
    fet430uif_write_single_register,
    fet430uif_read_mem,
    fet430uif_write_mem,
    fet430uif_resume_from_current,
    fet430uif_resume_from_addr,
    fet430uif_go_waiting,
    fet430uif_wait_partial,
    fet430uif_wait,
    fet430uif_process_query,
    fet430uif_list_query,
    fet430uif_current_thread_query,
    fet430uif_offsets_query,
    fet430uif_crc_query,
    fet430uif_raw_query,
    fet430uif_remcmd,
    fet430uif_add_break,
    fet430uif_remove_break
};

struct fet430uif_status_s
{
    /* Start up parameters, set by fet430uif_open */

    log_func    log;
    int         is_open;
    usbcom_t    com;

    /*   
     * Tell wait_xxx method the notion of whether or not
     *   previously called resume is supported
     */

    int         target_running;
    int         target_interrupted;

    /*  
     *   registers are stored in MSP430's byteorder 
     */
    RP_FET430UIF_REG_DATATYPE    registers[RP_FET430UIF_NUM_REGS];
    uint64_t                     breakpoints[RP_FET430UIF_MAX_BREAKPOINTS];
};

static struct fet430uif_status_s fet430uif_status =
{
    NULL,  /* log */
    FALSE, /* is_open */
    NULL,  /* com */
    FALSE, /* target_running */
    FALSE, /* target_interrupted */
    {0},   /* registers */
    {0}    /* breakpoints */
};

/* Local functions */
static char *fet430uif_out_treg(char *in, unsigned int reg_no);
static int refresh_registers(void);

/* Target method */

#ifdef NDEBUG
#define DEBUG_OUT(...)
#else
static void DEBUG_OUT(const char *string,...)
{
    va_list args;
    va_start (args, string);
    fprintf (stderr, "debug: ");
    vfprintf (stderr, string, args);
    fprintf (stderr, "\n");
    va_end (args);
}
#endif

static void fet430uif_help(const char *prog_name)
{
    printf("This is the fet430uif target for the GDB proxy server. Usage:\n\n");
    printf("  %s [options] %s [fet430uif-options] [port]\n",
           prog_name,
           fet430uif_target.name);
    printf("\nOptions:\n\n");
    printf("  --debug              run %s in debug mode\n", prog_name);
    printf("  --help               `%s --help %s'  prints this message\n",
           prog_name, fet430uif_target.name);
    printf("  --port=PORT          use the specified TCP port\n");
    printf("\nfet430uif-options:\n\n");

    printf("\n");

    return;
}

/* 
 *    FET430UIF functions 
 */

static int debug = 1;

/* boot3410.c */

#define B3410_BUFFER_SIZE 32768

static uint8_t calc_checksum(uint8_t *buf, int len)
{
  uint8_t sum;

  sum = 0;
  while (len--)
    sum += *buf++;

  return sum;
}
  
static int send3410(uint8_t *buf, int size, 
                    int vendor, int product)
{
  int r = 0;
  usbcom_t com;

  com = usbcom_open(vendor, product);
  if (com == NULL)
      return 1;

  if (usbcom_npipe(com) == 1) {
    r = usbcom_send(com, 1, buf, size);
    if (r)
      fprintf(stderr, "usbcom_send returned non zero value (%d, 0x%x)\n", r, r);

    usbcom_re_enumerate(com);

    sleep(1);  /* Wait for re-enumeration to take place */
  }

  usbcom_close(com);

  return r;
}

/* 
 * Public function: boot3410()
 *
 *   vendor  : vendor id.
 *   product : product id.
 *   fname   : Path to boot-code ("umpf3410.i51")
 *
 * Returns non-zero value if error.
 *   
 */

static int boot3410(int vendor, int product, const char *fname)
{
  FILE *fp;
  int n, r;
  uint8_t *buffer;

  if ((fp = fopen(fname, "rb")) == NULL)
      return 1;
  
  if ((buffer = malloc(B3410_BUFFER_SIZE)) == NULL)
      return 1;

  n = fread(buffer + 3, 1, B3410_BUFFER_SIZE, fp);

  /* TUSB3410 program should be within 16KBytes */

  if ((n > 0) && (n < 16385)) { 
    uint8_t cs;

    cs = calc_checksum(buffer + 3, n);

    buffer[0] = (n & 0xff);
    buffer[1] = ((n>>8) & 0xff);
    buffer[2] = cs;

    r = send3410(buffer, n + 3, vendor, product);

  } else { 
    /* no data or too much data  */
    r = 1;
  }

  free(buffer);

  return r;
}
/* end of boot3410.c */

static int sender(uint8_t *buf, int size)
{
  int r;

  if (debug>3) { 
    int i;
    fprintf(stderr, "sender: sending %d bytes\n", size);
    for (i=0; i < size; i++)
      fprintf(stderr, "%02x\n", buf[i]);
  }

  r = usbcom_send(fet430uif_status.com, 1, buf, size);
  
  if (r)
      fprintf(stderr, "usbcom_send returned non zero value (0x%x)\n", r);

  return 0;
}

static int reader(uint8_t *buf, int size)
{
  int n;

  n = usbcom_receive(fet430uif_status.com, 2, buf, size);
  
  if (debug>3) { 
    int i;
    fprintf(stderr, "reader: received %d bytes\n", n);
    for (i=0; i < n; i++)
      fprintf(stderr, "%02x\n", buf[i]);
  }

  return n;
}

/*
 * TUSB3410FIRM : path to the firmware binary file
 *
 *   umpf3410.i51 : comes with TI's VCP softwre 
 *   firm.flat    : modified version of ``firmware-0.1.tar.gz''
 *                  in http://sourceforge.net/projects/uticom.
 */

#ifndef TUSB3410FIRM
/*#define TUSB3410FIRM "umpf3410.i51" */
#define TUSB3410FIRM "/usr/local/msp430/fet430uif/tusb3410.bin"
#endif

static usbcom_t open_fet430uif(void)
{
  usbcom_t com;
  int vendor, product;

  vendor  = 0x0451;   /* Texas Instruments */
  product = 0xf430;   /* FET430UIF         */

  com = usbcom_open(vendor, product);
  if (com == NULL) {
      fprintf(stderr, "USB open failed 0x%04x/0x%04x\n", 
                       vendor, product);
      return NULL;
  }
  
  if (usbcom_npipe(com) != 3) {

    /*
     * We need 3 pipes to deal with FET430
     * Put TUSB3410 firmware and retry     
     *
     */
    usbcom_close(com);

    if (debug)
      fprintf(stderr, "init: loading TUSB3410 firmwre\n");

    boot3410(vendor, product, TUSB3410FIRM);

    com = usbcom_open(vendor, product); 

    if ((com == NULL) || (usbcom_npipe(com) != 3)) {
        fprintf(stderr, "USB open failed 0x%04x/0x%04x", vendor, product);
        
        return NULL;
    }
  }
  return com;
}



/* Target method */
static int fet430uif_open(int argc,
                         char * const argv[],
                         const char *prog_name,
                         log_func log_fn)
{
    /* Option descriptors */
    static struct option long_options[] =
    {
        /* Options setting flag */
        {NULL, 0, 0, 0}
    };

    assert(!fet430uif_status.is_open);
    assert(prog_name != NULL);
    assert(log_fn != NULL);

    /* Set log */
    fet430uif_status.log = log_fn;

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_open()",
                        fet430uif_target.name);

    /* Process options */
    for (;;)
    {
        int c;
        int option_index;

        c = getopt_long(argc, argv, "+", long_options, &option_index);
        if (c == EOF)
            break;
        switch (c)
        {
        case 0:
            /* Long option which just sets a flag */
            break;
        default:
            fet430uif_status.log(RP_VAL_LOGLEVEL_NOTICE,
                                "%s: Use `%s --help %s' to see a complete list of options",
                                fet430uif_target.name,
                                prog_name,
                                fet430uif_target.name);
            return RP_VAL_TARGETRET_ERR;
        }
    }

    if (!fet430uif_status.is_open)
    {
        /* TODO: initialise the target interface */

        fet430uif_status.com = open_fet430uif();

        if (fet430uif_status.com == NULL)
            return RP_VAL_TARGETRET_ERR;

        if (fet430_open(sender, reader) != 0) {
            usbcom_close(fet430uif_status.com);

            fprintf(stderr, "Failed to open FET430UIF");
            return RP_VAL_TARGETRET_ERR;
        }
    }

    /* TODO: Perform any initial target configuration. Perhaps check if the
       target is actually there. */
    { 
        int vcc; 
        uint8_t cpuid[80];
    
        /* fet430_Configure(INTERFACE_MODE, SPYBIWIREJTAG_IF); */
        fet430_Configure(INTERFACE_MODE, JTAG_IF);

        fet430_GetCurVCCT(&vcc);
        fprintf(stderr, "Target VCC = %f V\n", (double)vcc / 1000);

        vcc = 3300;
        fprintf(stderr, "Setting Target VCC to %f V\n", (double)vcc / 1000);
        fet430_VCC(vcc);
        /* sleep(2); */

        vcc = 0;
        fet430_GetCurVCCT(&vcc);
        fprintf(stderr, "Target VCC = %f V\n", (double)vcc / 1000);
        /* sleep(2); */

        if (vcc > 2900)
            fet430_Identify(cpuid, 80, 0);
        else
            return RP_VAL_TARGETRET_ERR;

    }

    /* Set up initial default values */
    fet430uif_status.target_running = FALSE;
    fet430uif_status.target_interrupted = FALSE;

    memset (fet430uif_status.registers, 0, sizeof(fet430uif_status.registers));
    memset (fet430uif_status.breakpoints, 0, sizeof(fet430uif_status.breakpoints));

    fet430uif_status.is_open = TRUE;

    return RP_VAL_TARGETRET_OK;
}

static void read_regs(RP_FET430UIF_REG_DATATYPE regs[])
{
    int i, r[RP_FET430UIF_NUM_REGS];
    uint8_t *p;


    fet430_ReadRegisters(r);

    p = (uint8_t *)regs;
    for (i=0; i < RP_FET430UIF_NUM_REGS; i++) {
        *p++ = r[i];
        *p++ = (r[i]>>8);
    }
}

static void write_regs(RP_FET430UIF_REG_DATATYPE regs[])
{
    int i, r[RP_FET430UIF_NUM_REGS];
    uint8_t *p;

    p = (uint8_t *)regs;
    for (i=0; i < RP_FET430UIF_NUM_REGS; i++) {
        r[i] = *p++;
        r[i] += (*p++ << 8);
    }
    fet430_WriteRegisters(r);
}

static void set_fet430uif_status_registers(int idx, int val)
{
    uint8_t *p;

    p = (uint8_t *)&fet430uif_status.registers[idx];

    *p++ = val;
    *p++ = (val>>8);
}

static int fet430uif_status_registers(int idx)
{
    uint8_t *p;
    int val;

    p = (uint8_t *)&fet430uif_status.registers[idx];

    val = *p++;
    val += (*p++ << 8);

    return val;
}

/* Target method */
static void fet430uif_close(void)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_close()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    /* TODO: Tidy up things and shut down. */

    fet430_cleanup();
    usbcom_close(fet430uif_status.com);
    
    fet430uif_status.is_open = FALSE;
}

/* Target method */

static int fet430uif_connect(char *status_string,
                            size_t status_string_len,
                            int *can_restart)
{
    char *cp;

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_connect()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    assert(status_string != NULL);
    assert(status_string_len >= 34);
    assert(can_restart != NULL);

    *can_restart = TRUE;

    /* Fill out the the status string */
    sprintf(status_string, "T%02d", RP_SIGNAL_ABORTED);

    if (refresh_registers())
        return RP_VAL_TARGETRET_ERR;
    
    cp = fet430uif_out_treg(&status_string[3], RP_FET430UIF_REGNUM_PC);
    cp = fet430uif_out_treg(cp, RP_FET430UIF_REGNUM_FP);

    return (cp != NULL)  ?  RP_VAL_TARGETRET_OK  :  RP_VAL_TARGETRET_ERR;
}

/* Target method */
static int fet430uif_disconnect(void)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_disconnect()",
                        fet430uif_target.name);

    return RP_VAL_TARGETRET_NOSUPP;
}

/* Target method */
static void fet430uif_kill(void)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_kill()",
                        fet430uif_target.name);

    /* TODO: Kill the target debug session. */
}

static int fet430uif_restart(void)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_restart()",
                        fet430uif_target.name);

    /* Just stop it. The actual restart will be done
       when connect is called again */

    fet430uif_stop();

    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static void fet430uif_stop(void)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_stop()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    /* TODO: Stop (i,e, break) the target program. */

    {
        int state;
        int CPUCycles;

        fet430_State(&state, 1, &CPUCycles);
    }

    fet430uif_status.target_interrupted = TRUE;
}

static int fet430uif_set_gen_thread(rp_thread_ref *thread)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_set_gen_thread()",
                        fet430uif_target.name);

    return RP_VAL_TARGETRET_NOSUPP;
}

/* Target method */
static int fet430uif_set_ctrl_thread(rp_thread_ref *thread)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_set_ctrl_thread()",
                        fet430uif_target.name);

    return RP_VAL_TARGETRET_NOSUPP;
}

/* Target method */
static int fet430uif_is_thread_alive(rp_thread_ref *thread, int *alive)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_is_thread_alive()",
                        fet430uif_target.name);

    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_read_registers(uint8_t *data_buf,
                                 uint8_t *avail_buf,
                                 size_t buf_size,
                                 size_t *read_size)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_read_registers()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    assert(data_buf != NULL);
    assert(avail_buf != NULL);
    assert(buf_size >= RP_FET430UIF_REG_BYTES);
    assert(read_size != NULL);

    if (refresh_registers())
        return RP_VAL_TARGETRET_ERR;

    memcpy(data_buf, fet430uif_status.registers, RP_FET430UIF_REG_BYTES);
    memset(avail_buf, 1, RP_FET430UIF_REG_BYTES);

    *read_size = RP_FET430UIF_REG_BYTES;
    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_write_registers(uint8_t *buf, size_t write_size)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_write_registers()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    assert(buf != NULL);
    assert(write_size > 0);
    assert(write_size <= RP_FET430UIF_REG_BYTES);

    memcpy(fet430uif_status.registers, buf, write_size);

    /* TODO: Write the registers to the target. */

    write_regs(fet430uif_status.registers);

    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_read_single_register(unsigned int reg_no,
                                         uint8_t *data_buf,
                                         uint8_t *avail_buf,
                                         size_t buf_size,
                                         size_t *read_size)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_read_single_register()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    assert(data_buf != NULL);
    assert(avail_buf != NULL);
    assert(buf_size >= RP_FET430UIF_REG_BYTES);
    assert(read_size != NULL);

    if (reg_no < 0  ||  reg_no > RP_FET430UIF_NUM_REGS);
        return RP_VAL_TARGETRET_ERR;

    if (refresh_registers())
        return RP_VAL_TARGETRET_ERR;

    memcpy(data_buf, &fet430uif_status.registers[reg_no], sizeof(fet430uif_status.registers[reg_no]));
    memset(avail_buf, 1, sizeof(fet430uif_status.registers[reg_no]));
    *read_size = sizeof(fet430uif_status.registers[reg_no]);
    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_write_single_register(unsigned int reg_no,
                                          uint8_t *buf,
                                          size_t write_size)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_write_single_register(%d, 0x%X)",
                        fet430uif_target.name,
                        reg_no,
                        ((RP_FET430UIF_REG_DATATYPE *) buf)[0]);

    assert(fet430uif_status.is_open);

    assert(buf != NULL);
    assert(write_size == 2);

    if (reg_no < 0  ||  reg_no > RP_FET430UIF_NUM_REGS)
        return RP_VAL_TARGETRET_ERR;

    /* TODO: Write the register to the target. */
    
    /* read_regs(fet430uif_status.registers); */
    
    /*
     * buf comes in msp430's byte order, and we keep 
     * fet430uif_status.registers in
     * the same way 
     */
    fet430uif_status.registers[reg_no] = ((RP_FET430UIF_REG_DATATYPE *) buf)[0];

    write_regs(fet430uif_status.registers);

    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_read_mem(uint64_t addr,
                             uint8_t *buf,
                             size_t req_size,
                             size_t *actual_size)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_read_mem(0x%llX, ptr, %d, ptr)",
                        fet430uif_target.name,
                        addr,
                        req_size);

    assert(fet430uif_status.is_open);

    assert(buf != NULL);
    assert(req_size > 0);
    assert(actual_size != NULL);

    if (addr > RP_FET430UIF_MAX_ADDRESS)
    {
        fet430uif_status.log(RP_VAL_LOGLEVEL_ERR,
                            "%s: bad address 0x%llx",
                            fet430uif_target.name,
                            addr);

        return RP_VAL_TARGETRET_ERR;
    }

    if (addr + req_size > RP_FET430UIF_MAX_ADDRESS + 1)
        *actual_size = RP_FET430UIF_MAX_ADDRESS + 1 - addr;
    else
        *actual_size = req_size;

    /* TODO: Read the required block of memory from the target. */
    fet430_Read_Memory(addr, buf, *actual_size);

    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_write_mem(uint64_t addr,
                              uint8_t *buf,
                              size_t write_size)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_write_mem(0x%llX, ptr, %d)",
                        fet430uif_target.name,
                        addr,
                        write_size);

    assert(fet430uif_status.is_open);
    assert(buf != NULL);

    /* GDB does zero length writes for some reason. Treat them harmlessly. */
    if (write_size == 0)
        return RP_VAL_TARGETRET_OK;

    if (addr > RP_FET430UIF_MAX_ADDRESS)
    {
        fet430uif_status.log(RP_VAL_LOGLEVEL_ERR,
                            "%s: bad address 0x%llx",
                            fet430uif_target.name,
                            addr);
        return RP_VAL_TARGETRET_ERR;
    }

    if ((addr + write_size - 1) > RP_FET430UIF_MAX_ADDRESS)
    {
        fet430uif_status.log(RP_VAL_LOGLEVEL_ERR,
                            "%s: bad address/write_size 0x%llx/0x%x",
                            fet430uif_target.name,
                            addr,
                            write_size);
        return RP_VAL_TARGETRET_ERR;
    }

    /* TODO: Write to the target. */

    fet430_Write_Memory(addr, buf, write_size);

    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_resume_from_current(int step, int sig)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_resume_from_current(%s, %d)",
                        fet430uif_target.name,
                        (step)  ?  "step"  :  "run",
                        sig);

    assert(fet430uif_status.is_open);

    if (step) {
        /* TODO: Single step the target */
        fet430_Run(SINGLE_STEP, 0);
    } else {
        /* TODO: Run the target to a breakpoint, or until we stop it. */
        fet430_Run(RUN_TO_BREAKPOINT, 0);
    }

    fet430uif_status.target_running = TRUE;
    fet430uif_status.target_interrupted = FALSE;
    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_resume_from_addr(int step, int sig, uint64_t addr)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_resume_from_addr(%s, %d, 0x%llX)",
                        fet430uif_target.name,
                        (step)  ?  "step"  :  "run",
                        sig,
                        addr);

    assert(fet430uif_status.is_open);

    /* read_regs(fet430uif_status.registers); */

    /* TODO: Update the PC register in the target */

    set_fet430uif_status_registers(RP_FET430UIF_REGNUM_PC, addr);
    write_regs(fet430uif_status.registers);
    
    /* TODO: Run the target from the new PC address. */

    fet430_Run(RUN_TO_BREAKPOINT, 0);

    fet430uif_status.target_running = TRUE;
    fet430uif_status.target_interrupted = FALSE;

    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_go_waiting(int sig)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_go_waiting()",
                        fet430uif_target.name);

    return RP_VAL_TARGETRET_NOSUPP;
}

/* Target method */
static int fet430uif_wait_partial(int first,
                                 char *status_string,
                                 size_t status_string_len,
                                 out_func of,
                                 int *implemented,
                                 int *more)
{
    int state;
    char *cp;
    int sig;

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_wait_partial()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    assert(status_string != NULL);
    assert(status_string_len >= 34);
    assert(of != NULL);
    assert(implemented != NULL);
    assert(more != NULL);

    *implemented = TRUE;

    if (!fet430uif_status.target_running)
        return RP_VAL_TARGETRET_NOSUPP;

#ifdef WIN32
    sleep((first)  ?  500  :  100);
#else
    usleep((first)  ?  500000  :  100000);
#endif

    /* TODO: Test the target state (i.e. running/stopped) without blocking */

    {
        int s, CPUCycles;

        fet430_State(&s, 0, &CPUCycles);

        switch (s) {
        case STOPPED:
            state = RP_FET430UIF_TARGET_STATE_STOPPED;
            break;
        case RUNNING:
            state = RP_FET430UIF_TARGET_STATE_RUNNING;
            break;
        case SINGLE_STEP_COMPLETE:
            state = RP_FET430UIF_TARGET_STATE_SINGLE_STEP_COMPLETE;
            break;
        case BREAKPOINT_HIT:
            state = RP_FET430UIF_TARGET_STATE_BREAKPOINT_HIT;
            break;
        default:
            state = RP_FET430UIF_TARGET_STATE_RUNNING;
        }

    }

    /* If the target only supports a blocking form of test return no support,
       and the blocking version of this test will be called instead. That is
       not so nice, as the system is less interactive using a blocking test. */

    if (state == RP_FET430UIF_TARGET_STATE_RUNNING)
    {
        *more = TRUE;
        return RP_VAL_TARGETRET_OK;
    }

    switch (state)
    {
    case RP_FET430UIF_TARGET_STATE_STOPPED:
        if (fet430uif_status.target_interrupted)
            sig = RP_SIGNAL_INTERRUPT;
        else
            sig = RP_SIGNAL_ABORTED;
        break;
    case RP_FET430UIF_TARGET_STATE_RUNNING:
        *more = TRUE;
        return RP_VAL_TARGETRET_OK;
    case RP_FET430UIF_TARGET_STATE_SINGLE_STEP_COMPLETE:
        sig = RP_SIGNAL_BREAKPOINT;
        break;
    case RP_FET430UIF_TARGET_STATE_BREAKPOINT_HIT:
        sig = RP_SIGNAL_BREAKPOINT;
        break;
    default:
        fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                            "%s: unexpected state %d for the FET430UIF",
                            fet430uif_target.name,
                            state);
        sig = RP_SIGNAL_ABORTED;
        break;
    }
    /* Fill out the status string */
    sprintf(status_string, "T%02d", sig);

    if (refresh_registers())
        return RP_VAL_TARGETRET_ERR;
    
    cp = fet430uif_out_treg(&status_string[3], RP_FET430UIF_REGNUM_PC);
    cp = fet430uif_out_treg(cp, RP_FET430UIF_REGNUM_FP);

    *more = FALSE;

    return (cp != NULL)  ?  RP_VAL_TARGETRET_OK  :  RP_VAL_TARGETRET_ERR;
}

/* Target method */
static int fet430uif_wait(char *status_string,
                         size_t status_string_len,
                         out_func of,
                         int *implemented)
{
    int state;
    char *cp;
    int sig;

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_wait()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    assert(status_string != NULL);
    assert(status_string_len >= 34);
    assert(of != NULL);
    assert(implemented != NULL);

    *implemented = TRUE;

    if (!fet430uif_status.target_running)
        return RP_VAL_TARGETRET_NOSUPP;

    /* TODO: Wait for the target to stop */
    {
        int s, c;

        for (s = RUNNING; fet430_State(&s, 0, &c); sleep(1))
            ;
        
        switch (s) {
        case STOPPED:
            state = RP_FET430UIF_TARGET_STATE_STOPPED;
            break;
        case RUNNING:
            state = RP_FET430UIF_TARGET_STATE_RUNNING;
            break;
        case SINGLE_STEP_COMPLETE:
            state = RP_FET430UIF_TARGET_STATE_SINGLE_STEP_COMPLETE;
            break;
        case BREAKPOINT_HIT:
            state = RP_FET430UIF_TARGET_STATE_BREAKPOINT_HIT;
            break;
        default:
            state = RP_FET430UIF_TARGET_STATE_RUNNING;
        }
    }

    switch (state)
    {
    case RP_FET430UIF_TARGET_STATE_STOPPED:
        sig = RP_SIGNAL_ABORTED;
        break;
    case RP_FET430UIF_TARGET_STATE_SINGLE_STEP_COMPLETE:
        sig = RP_SIGNAL_BREAKPOINT;
        break;
    case RP_FET430UIF_TARGET_STATE_BREAKPOINT_HIT:
        sig = RP_SIGNAL_BREAKPOINT;
        break;
    default:
        fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                            "%s: unexpected state %d for the FET430UIF",
                            fet430uif_target.name,
                            state);
        sig = RP_SIGNAL_ABORTED;
        break;
    }

    /* Fill out the status string */
    sprintf(status_string, "T%02d", sig);
    if (refresh_registers())
        return RP_VAL_TARGETRET_ERR;
    
    cp = fet430uif_out_treg(&status_string[3], RP_FET430UIF_REGNUM_PC);
    cp = fet430uif_out_treg(cp, RP_FET430UIF_REGNUM_FP);

    return (cp != NULL)  ?  RP_VAL_TARGETRET_OK  :  RP_VAL_TARGETRET_ERR;
}

/* Target method */
static int fet430uif_process_query(unsigned int *mask,
                                  rp_thread_ref *arg,
                                  rp_thread_info *info)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_process_query()",
                        fet430uif_target.name);
    /* TODO: Does your target support threads? Is so, implement this function.
       Otherwise just return no support. */
    return RP_VAL_TARGETRET_NOSUPP;
}

/* Target method */
static int fet430uif_list_query(int first,
                               rp_thread_ref *arg,
                               rp_thread_ref *result,
                               size_t max_num,
                               size_t *num,
                               int *done)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_list_query()",
                        fet430uif_target.name);
    /* TODO: Does your target support threads? Is so, implement this function.
       Otherwise just return no support. */
    return RP_VAL_TARGETRET_NOSUPP;
}

/* Target method */
static int fet430uif_current_thread_query(rp_thread_ref *thread)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_current_thread_query()",
                        fet430uif_target.name);
    /* TODO: Does your target support threads? Is so, implement this function.
       Otherwise just return no support. */
    return RP_VAL_TARGETRET_NOSUPP;
}

/* Target method */
static int fet430uif_offsets_query(uint64_t *text, uint64_t *data, uint64_t *bss)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_offsets_query()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    assert(text != NULL);
    assert(data != NULL);
    assert(bss != NULL);

    /* TODO: Is this what *your* target really needs? */
    *text = 0;
    *data = 0;
    *bss = 0;
    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_crc_query(uint64_t addr, size_t len, uint32_t *val)
{
    uint8_t buf[65536];

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_crc_query()",
                        fet430uif_target.name);

    assert(fet430uif_status.is_open);

    if (addr > RP_FET430UIF_MAX_ADDRESS  ||  addr + len > RP_FET430UIF_MAX_ADDRESS + 1)
    {
        fet430uif_status.log(RP_VAL_LOGLEVEL_ERR,
                            "%s: bad address 0x%llx",
                            fet430uif_target.name,
                            addr);

        return RP_VAL_TARGETRET_ERR;
    }

    /* TODO: Read the target memory,and use the crc32 routine to calculate
       the CRC value to be returned. */
    /* Note: The CRC can be calculated in chunks. The first call to crc32
       should set the current CRC value to all 1's, as this is the priming
       value for CRC32. Subsequent calls should set the current CRC to the
       value returned by the previous call, until all the data has been
       processed. */

    fet430_Read_Memory(addr, buf, len);

    *val = crc32(buf, len, 0xFFFFFFFF);

    return RP_VAL_TARGETRET_OK;
}

/* Target method */
static int fet430uif_raw_query(char *in_buf, char *out_buf, size_t out_buf_size)
{
    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_raw_query()",
                        fet430uif_target.name);

    return RP_VAL_TARGETRET_NOSUPP;
}

static int tohex(char *s, const char *t)
{
    int i;
    static char hex[] = "0123456789abcdef";

    i = 0;
    while (*t)
    {
        *s++ = hex[(*t >> 4) & 0x0f];
        *s++ = hex[*t & 0x0f];
        t++;
        i++;
    }
    *s = '\0';
    return i;
}

/* command: erase flash */
static int fet430uif_rcmd_erase(int argc, char *argv[], out_func of, data_func df)
{
    char buf[1000 + 1];

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_rcmd_erase()",
                        fet430uif_target.name);
    tohex(buf, "Erasing target flash - ");
    of(buf);

    /* TODO: perform the erase. */

    fet430_Erase(ERASE_ALL, 0x1100, 512); /* XXX */

    tohex(buf, " Erased OK\n");
    of(buf);
    return RP_VAL_TARGETRET_OK;
}

/* Table of commands */
static const RCMD_TABLE remote_commands[] =
{
    RCMD(help,      "This help text"),

    RCMD(erase,     "Erase target flash memory"),
    {0,0,0}     //sentinel, end of table marker
};

/* Help function, generate help text from command table */
static int fet430uif_rcmd_help(int argc, char *argv[], out_func of, data_func df)
{
    char buf[1000 + 1];
    char buf2[1000 + 1];
    int i = 0;

    tohex(buf, "Remote command help:\n");
    of(buf);
    for (i = 0;  remote_commands[i].name;  i++)
    {
#ifdef WIN32
        sprintf(buf2, "%-10s %s\n", remote_commands[i].name, remote_commands[i].help);
#else
        snprintf(buf2, 1000, "%-10s %s\n", remote_commands[i].name, remote_commands[i].help);
#endif
        tohex(buf, buf2);
        of(buf);
    }
    return RP_VAL_TARGETRET_OK;
}

/* Decode nibble */
static int remote_decode_nibble(const char *in, unsigned int *nibble)
{
    unsigned int nib;

    if ((nib = rp_hex_nibble(*in)) >= 0)
    {
        *nibble = nib;
        return  TRUE;
    }

    return  FALSE;
}


/* Decode byte */
static int remote_decode_byte(const char *in, unsigned int *byte)
{
    unsigned int ls_nibble;
    unsigned int ms_nibble;

    if (!remote_decode_nibble(in, &ms_nibble))
        return  FALSE;

    if (!remote_decode_nibble(in + 1, &ls_nibble))
        return  FALSE;

    *byte = (ms_nibble << 4) + ls_nibble;

    return  TRUE;
}


/* Target method */
#define MAXARGS 4
static int fet430uif_remcmd(char *in_buf, out_func of, data_func df)
{
    int count = 0;
    int i;
    char *args[MAXARGS];
    char *ptr;
    unsigned int ch;
    char buf[1000 + 1];
    char *s;

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_remcmd()",
                        fet430uif_target.name);
    DEBUG_OUT("command '%s'", in_buf);

    if (strlen(in_buf))
    {
        /* There is something to process */
        /* TODO: Handle target specific commands, such as flash erase, JTAG
                 control, etc. */
        /* A single example "flash erase" command is partially implemented
           here as an example. */
        
        /* Turn the hex into ASCII */
        ptr = in_buf;
        s = buf;
        while (*ptr)
        {
            if (remote_decode_byte(ptr, &ch) == 0)
                return RP_VAL_TARGETRET_ERR;
            *s++ = ch;
            ptr += 2;
        }
        *s = '\0';
        DEBUG_OUT("command '%s'", buf);
        
        /* Split string into separate arguments */
        ptr = buf;
        args[count++] = ptr;
        while (*ptr)
        {
            /* Search to the end of the string */
            if (*ptr == ' ')
            {
                /* Space is the delimiter */
                *ptr = 0;
                if (count >= MAXARGS)
                    return RP_VAL_TARGETRET_ERR;
                args[count++] = ptr + 1;
            }
            ptr++;
        }
        /* Search the command table, and execute the function if found */
        DEBUG_OUT("executing target dependant command '%s'", args[0]);

        for (i = 0;  remote_commands[i].name;  i++)
        {
            if (strcmp(args[0], remote_commands[i].name) == 0)
                return remote_commands[i].function(count, args, of, df);
        }
        return RP_VAL_TARGETRET_NOSUPP;
    }
    return RP_VAL_TARGETRET_ERR;
}


/* Target method */
static int fet430uif_add_break(int type, uint64_t addr, unsigned int len)
{
    int i;

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_add_break(%d, 0x%llx, %d)",
                        fet430uif_target.name,
                        type,
                        addr,
                        len);
    /* TODO: Handle whichever types of breakpoint the target can support, and
       report no support for the others. */

    if ((type == RP_BP_TYPE_SOFTWARE) ||
        (type == RP_BP_TYPE_HARDWARE)) {
        
        for (i=0; i < RP_FET430UIF_MAX_BREAKPOINTS; i++) {
            if (fet430uif_status.breakpoints[i] == 0) { 

                fet430uif_status.breakpoints[i] = addr;
                fet430_Breakpoint(i, addr);

                return RP_VAL_TARGETRET_OK;
            }
        }
    }

    return RP_VAL_TARGETRET_NOSUPP;
}

/* Target method */
static int fet430uif_remove_break(int type, uint64_t addr, unsigned int len)
{
    int i;

    fet430uif_status.log(RP_VAL_LOGLEVEL_DEBUG,
                        "%s: fet430uif_remove_break(%d, 0x%llx, %d)",
                        fet430uif_target.name,
                        type,
                        addr,
                        len);
    /* TODO: Handle whichever types of breakpoint the target can support, and
       report no support for the others. */

    if ((type == RP_BP_TYPE_SOFTWARE) ||
        (type == RP_BP_TYPE_HARDWARE)) {
        
        for (i=0; i < RP_FET430UIF_MAX_BREAKPOINTS; i++) {
            if (fet430uif_status.breakpoints[i] == addr) { 
        
                fet430uif_status.breakpoints[i] = 0;
                fet430_Breakpoint(i, 0);

                return RP_VAL_TARGETRET_OK;
            }
        }
    }

    return RP_VAL_TARGETRET_NOSUPP;
}

/* Output registers in the format suitable
   for TAAn:r...;n:r...;  format */
static char *fet430uif_out_treg(char *in, unsigned int reg_no)
{
    static const char hex[] = "0123456789abcdef";
    int16_t reg_val;

    if (in == NULL)
        return NULL;

    assert(reg_no < RP_FET430UIF_NUM_REGS);

    *in++ = hex[(reg_no >> 4) & 0x0f];
    *in++ = hex[reg_no & 0x0f];
    *in++ = ':';

    reg_val = fet430uif_status_registers(reg_no);

    /* The register goes into the buffer in little-endian order */
    *in++ = hex[(reg_val >> 4) & 0x0f];
    *in++ = hex[reg_val & 0x0f];
    *in++ = hex[(reg_val >> 12) & 0x0f];
    *in++ = hex[(reg_val >> 8) & 0x0f];
    *in++ = ';';
    *in   = '\0';

    return in;
}

/* Table used by the crc32 function to calcuate the checksum. */
static uint32_t crc32_table[256] =
{
    0,
    0
};

static uint32_t crc32(uint8_t *buf, size_t len, uint32_t crc)
{
    if (!crc32_table[1])
    {
        /* Initialize the CRC table and the decoding table. */
        int i;
        int j;
        unsigned int c;

        for (i = 0; i < 256; i++)
	{
	    for (c = i << 24, j = 8; j > 0; --j)
	        c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	    crc32_table[i] = c;
	}
    }

    while (len--)
    {
        crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
        buf++;
    }
    return crc;
}

static int refresh_registers(void)
{

    read_regs(fet430uif_status.registers);

    return  0;
}

/* 
Local Variables:
c-basic-offset: 4
End:
*/
